// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'executable_declaration.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ExecutableParameterDeclaration {
  /// whether the parameter is required
  bool get isRequired => throw _privateConstructorUsedError;

  /// whether the parameter is named
  bool get isNamed => throw _privateConstructorUsedError;

  /// the name of the parameter
  String get name => throw _privateConstructorUsedError;

  /// whether the parameter is deprecated
  bool get isDeprecated => throw _privateConstructorUsedError;

  /// whether the parameter is experimental
  bool get isExperimental => throw _privateConstructorUsedError;

  /// type name of this parameter
  String get typeName => throw _privateConstructorUsedError;

  /// the type library path
  String? get typeFullLibraryName => throw _privateConstructorUsedError;

  /// the relative path of the library
  String get relativePath => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExecutableParameterDeclarationCopyWith<ExecutableParameterDeclaration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExecutableParameterDeclarationCopyWith<$Res> {
  factory $ExecutableParameterDeclarationCopyWith(
          ExecutableParameterDeclaration value,
          $Res Function(ExecutableParameterDeclaration) then) =
      _$ExecutableParameterDeclarationCopyWithImpl<$Res,
          ExecutableParameterDeclaration>;
  @useResult
  $Res call(
      {bool isRequired,
      bool isNamed,
      String name,
      bool isDeprecated,
      bool isExperimental,
      String typeName,
      String? typeFullLibraryName,
      String relativePath});
}

/// @nodoc
class _$ExecutableParameterDeclarationCopyWithImpl<$Res,
        $Val extends ExecutableParameterDeclaration>
    implements $ExecutableParameterDeclarationCopyWith<$Res> {
  _$ExecutableParameterDeclarationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRequired = null,
    Object? isNamed = null,
    Object? name = null,
    Object? isDeprecated = null,
    Object? isExperimental = null,
    Object? typeName = null,
    Object? typeFullLibraryName = freezed,
    Object? relativePath = null,
  }) {
    return _then(_value.copyWith(
      isRequired: null == isRequired
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNamed: null == isNamed
          ? _value.isNamed
          : isNamed // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isDeprecated: null == isDeprecated
          ? _value.isDeprecated
          : isDeprecated // ignore: cast_nullable_to_non_nullable
              as bool,
      isExperimental: null == isExperimental
          ? _value.isExperimental
          : isExperimental // ignore: cast_nullable_to_non_nullable
              as bool,
      typeName: null == typeName
          ? _value.typeName
          : typeName // ignore: cast_nullable_to_non_nullable
              as String,
      typeFullLibraryName: freezed == typeFullLibraryName
          ? _value.typeFullLibraryName
          : typeFullLibraryName // ignore: cast_nullable_to_non_nullable
              as String?,
      relativePath: null == relativePath
          ? _value.relativePath
          : relativePath // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExecutableParameterDeclarationImplCopyWith<$Res>
    implements $ExecutableParameterDeclarationCopyWith<$Res> {
  factory _$$ExecutableParameterDeclarationImplCopyWith(
          _$ExecutableParameterDeclarationImpl value,
          $Res Function(_$ExecutableParameterDeclarationImpl) then) =
      __$$ExecutableParameterDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isRequired,
      bool isNamed,
      String name,
      bool isDeprecated,
      bool isExperimental,
      String typeName,
      String? typeFullLibraryName,
      String relativePath});
}

/// @nodoc
class __$$ExecutableParameterDeclarationImplCopyWithImpl<$Res>
    extends _$ExecutableParameterDeclarationCopyWithImpl<$Res,
        _$ExecutableParameterDeclarationImpl>
    implements _$$ExecutableParameterDeclarationImplCopyWith<$Res> {
  __$$ExecutableParameterDeclarationImplCopyWithImpl(
      _$ExecutableParameterDeclarationImpl _value,
      $Res Function(_$ExecutableParameterDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRequired = null,
    Object? isNamed = null,
    Object? name = null,
    Object? isDeprecated = null,
    Object? isExperimental = null,
    Object? typeName = null,
    Object? typeFullLibraryName = freezed,
    Object? relativePath = null,
  }) {
    return _then(_$ExecutableParameterDeclarationImpl(
      isRequired: null == isRequired
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNamed: null == isNamed
          ? _value.isNamed
          : isNamed // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isDeprecated: null == isDeprecated
          ? _value.isDeprecated
          : isDeprecated // ignore: cast_nullable_to_non_nullable
              as bool,
      isExperimental: null == isExperimental
          ? _value.isExperimental
          : isExperimental // ignore: cast_nullable_to_non_nullable
              as bool,
      typeName: null == typeName
          ? _value.typeName
          : typeName // ignore: cast_nullable_to_non_nullable
              as String,
      typeFullLibraryName: freezed == typeFullLibraryName
          ? _value.typeFullLibraryName
          : typeFullLibraryName // ignore: cast_nullable_to_non_nullable
              as String?,
      relativePath: null == relativePath
          ? _value.relativePath
          : relativePath // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExecutableParameterDeclarationImpl
    extends _ExecutableParameterDeclaration {
  const _$ExecutableParameterDeclarationImpl(
      {required this.isRequired,
      required this.isNamed,
      required this.name,
      required this.isDeprecated,
      required this.isExperimental,
      required this.typeName,
      required this.typeFullLibraryName,
      required this.relativePath})
      : super._();

  /// whether the parameter is required
  @override
  final bool isRequired;

  /// whether the parameter is named
  @override
  final bool isNamed;

  /// the name of the parameter
  @override
  final String name;

  /// whether the parameter is deprecated
  @override
  final bool isDeprecated;

  /// whether the parameter is experimental
  @override
  final bool isExperimental;

  /// type name of this parameter
  @override
  final String typeName;

  /// the type library path
  @override
  final String? typeFullLibraryName;

  /// the relative path of the library
  @override
  final String relativePath;

  @override
  String toString() {
    return 'ExecutableParameterDeclaration(isRequired: $isRequired, isNamed: $isNamed, name: $name, isDeprecated: $isDeprecated, isExperimental: $isExperimental, typeName: $typeName, typeFullLibraryName: $typeFullLibraryName, relativePath: $relativePath)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExecutableParameterDeclarationImpl &&
            (identical(other.isRequired, isRequired) ||
                other.isRequired == isRequired) &&
            (identical(other.isNamed, isNamed) || other.isNamed == isNamed) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.isDeprecated, isDeprecated) ||
                other.isDeprecated == isDeprecated) &&
            (identical(other.isExperimental, isExperimental) ||
                other.isExperimental == isExperimental) &&
            (identical(other.typeName, typeName) ||
                other.typeName == typeName) &&
            (identical(other.typeFullLibraryName, typeFullLibraryName) ||
                other.typeFullLibraryName == typeFullLibraryName) &&
            (identical(other.relativePath, relativePath) ||
                other.relativePath == relativePath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isRequired,
      isNamed,
      name,
      isDeprecated,
      isExperimental,
      typeName,
      typeFullLibraryName,
      relativePath);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExecutableParameterDeclarationImplCopyWith<
          _$ExecutableParameterDeclarationImpl>
      get copyWith => __$$ExecutableParameterDeclarationImplCopyWithImpl<
          _$ExecutableParameterDeclarationImpl>(this, _$identity);
}

abstract class _ExecutableParameterDeclaration
    extends ExecutableParameterDeclaration implements Declaration {
  const factory _ExecutableParameterDeclaration(
          {required final bool isRequired,
          required final bool isNamed,
          required final String name,
          required final bool isDeprecated,
          required final bool isExperimental,
          required final String typeName,
          required final String? typeFullLibraryName,
          required final String relativePath}) =
      _$ExecutableParameterDeclarationImpl;
  const _ExecutableParameterDeclaration._() : super._();

  @override

  /// whether the parameter is required
  bool get isRequired;
  @override

  /// whether the parameter is named
  bool get isNamed;
  @override

  /// the name of the parameter
  String get name;
  @override

  /// whether the parameter is deprecated
  bool get isDeprecated;
  @override

  /// whether the parameter is experimental
  bool get isExperimental;
  @override

  /// type name of this parameter
  String get typeName;
  @override

  /// the type library path
  String? get typeFullLibraryName;
  @override

  /// the relative path of the library
  String get relativePath;
  @override
  @JsonKey(ignore: true)
  _$$ExecutableParameterDeclarationImplCopyWith<
          _$ExecutableParameterDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExecutableDeclaration {
  /// name of the return type
  String get returnTypeName =>
      throw _privateConstructorUsedError; // fill library name of the return type
  String? get returnTypeFullLibraryName => throw _privateConstructorUsedError;

  /// name of the executable
  String get name => throw _privateConstructorUsedError;

  /// whether the executable is deprecated
  bool get isDeprecated => throw _privateConstructorUsedError;

  /// whether the executable is experimental
  bool get isExperimental => throw _privateConstructorUsedError;

  /// list of the executables parameters ([ExecutableOParameterDeclaration]s)
  List<ExecutableParameterDeclaration> get parameters =>
      throw _privateConstructorUsedError;

  /// type parameter names of this executable
  List<String> get typeParameterNames => throw _privateConstructorUsedError;

  /// type of the executable
  ExecutableType get type => throw _privateConstructorUsedError;

  /// whether the executable is a static method
  bool get isStatic => throw _privateConstructorUsedError;

  /// entry points for this executable
  Set<String>? get entryPoints => throw _privateConstructorUsedError;

  /// the relative path of the library
  String get relativePath => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExecutableDeclarationCopyWith<ExecutableDeclaration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExecutableDeclarationCopyWith<$Res> {
  factory $ExecutableDeclarationCopyWith(ExecutableDeclaration value,
          $Res Function(ExecutableDeclaration) then) =
      _$ExecutableDeclarationCopyWithImpl<$Res, ExecutableDeclaration>;
  @useResult
  $Res call(
      {String returnTypeName,
      String? returnTypeFullLibraryName,
      String name,
      bool isDeprecated,
      bool isExperimental,
      List<ExecutableParameterDeclaration> parameters,
      List<String> typeParameterNames,
      ExecutableType type,
      bool isStatic,
      Set<String>? entryPoints,
      String relativePath});
}

/// @nodoc
class _$ExecutableDeclarationCopyWithImpl<$Res,
        $Val extends ExecutableDeclaration>
    implements $ExecutableDeclarationCopyWith<$Res> {
  _$ExecutableDeclarationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnTypeName = null,
    Object? returnTypeFullLibraryName = freezed,
    Object? name = null,
    Object? isDeprecated = null,
    Object? isExperimental = null,
    Object? parameters = null,
    Object? typeParameterNames = null,
    Object? type = null,
    Object? isStatic = null,
    Object? entryPoints = freezed,
    Object? relativePath = null,
  }) {
    return _then(_value.copyWith(
      returnTypeName: null == returnTypeName
          ? _value.returnTypeName
          : returnTypeName // ignore: cast_nullable_to_non_nullable
              as String,
      returnTypeFullLibraryName: freezed == returnTypeFullLibraryName
          ? _value.returnTypeFullLibraryName
          : returnTypeFullLibraryName // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isDeprecated: null == isDeprecated
          ? _value.isDeprecated
          : isDeprecated // ignore: cast_nullable_to_non_nullable
              as bool,
      isExperimental: null == isExperimental
          ? _value.isExperimental
          : isExperimental // ignore: cast_nullable_to_non_nullable
              as bool,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ExecutableParameterDeclaration>,
      typeParameterNames: null == typeParameterNames
          ? _value.typeParameterNames
          : typeParameterNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ExecutableType,
      isStatic: null == isStatic
          ? _value.isStatic
          : isStatic // ignore: cast_nullable_to_non_nullable
              as bool,
      entryPoints: freezed == entryPoints
          ? _value.entryPoints
          : entryPoints // ignore: cast_nullable_to_non_nullable
              as Set<String>?,
      relativePath: null == relativePath
          ? _value.relativePath
          : relativePath // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExecutableDeclarationImplCopyWith<$Res>
    implements $ExecutableDeclarationCopyWith<$Res> {
  factory _$$ExecutableDeclarationImplCopyWith(
          _$ExecutableDeclarationImpl value,
          $Res Function(_$ExecutableDeclarationImpl) then) =
      __$$ExecutableDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String returnTypeName,
      String? returnTypeFullLibraryName,
      String name,
      bool isDeprecated,
      bool isExperimental,
      List<ExecutableParameterDeclaration> parameters,
      List<String> typeParameterNames,
      ExecutableType type,
      bool isStatic,
      Set<String>? entryPoints,
      String relativePath});
}

/// @nodoc
class __$$ExecutableDeclarationImplCopyWithImpl<$Res>
    extends _$ExecutableDeclarationCopyWithImpl<$Res,
        _$ExecutableDeclarationImpl>
    implements _$$ExecutableDeclarationImplCopyWith<$Res> {
  __$$ExecutableDeclarationImplCopyWithImpl(_$ExecutableDeclarationImpl _value,
      $Res Function(_$ExecutableDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? returnTypeName = null,
    Object? returnTypeFullLibraryName = freezed,
    Object? name = null,
    Object? isDeprecated = null,
    Object? isExperimental = null,
    Object? parameters = null,
    Object? typeParameterNames = null,
    Object? type = null,
    Object? isStatic = null,
    Object? entryPoints = freezed,
    Object? relativePath = null,
  }) {
    return _then(_$ExecutableDeclarationImpl(
      returnTypeName: null == returnTypeName
          ? _value.returnTypeName
          : returnTypeName // ignore: cast_nullable_to_non_nullable
              as String,
      returnTypeFullLibraryName: freezed == returnTypeFullLibraryName
          ? _value.returnTypeFullLibraryName
          : returnTypeFullLibraryName // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isDeprecated: null == isDeprecated
          ? _value.isDeprecated
          : isDeprecated // ignore: cast_nullable_to_non_nullable
              as bool,
      isExperimental: null == isExperimental
          ? _value.isExperimental
          : isExperimental // ignore: cast_nullable_to_non_nullable
              as bool,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ExecutableParameterDeclaration>,
      typeParameterNames: null == typeParameterNames
          ? _value._typeParameterNames
          : typeParameterNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ExecutableType,
      isStatic: null == isStatic
          ? _value.isStatic
          : isStatic // ignore: cast_nullable_to_non_nullable
              as bool,
      entryPoints: freezed == entryPoints
          ? _value._entryPoints
          : entryPoints // ignore: cast_nullable_to_non_nullable
              as Set<String>?,
      relativePath: null == relativePath
          ? _value.relativePath
          : relativePath // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExecutableDeclarationImpl extends _ExecutableDeclaration {
  const _$ExecutableDeclarationImpl(
      {required this.returnTypeName,
      required this.returnTypeFullLibraryName,
      required this.name,
      required this.isDeprecated,
      required this.isExperimental,
      required final List<ExecutableParameterDeclaration> parameters,
      required final List<String> typeParameterNames,
      required this.type,
      required this.isStatic,
      final Set<String>? entryPoints,
      required this.relativePath})
      : _parameters = parameters,
        _typeParameterNames = typeParameterNames,
        _entryPoints = entryPoints,
        super._();

  /// name of the return type
  @override
  final String returnTypeName;
// fill library name of the return type
  @override
  final String? returnTypeFullLibraryName;

  /// name of the executable
  @override
  final String name;

  /// whether the executable is deprecated
  @override
  final bool isDeprecated;

  /// whether the executable is experimental
  @override
  final bool isExperimental;

  /// list of the executables parameters ([ExecutableOParameterDeclaration]s)
  final List<ExecutableParameterDeclaration> _parameters;

  /// list of the executables parameters ([ExecutableOParameterDeclaration]s)
  @override
  List<ExecutableParameterDeclaration> get parameters {
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parameters);
  }

  /// type parameter names of this executable
  final List<String> _typeParameterNames;

  /// type parameter names of this executable
  @override
  List<String> get typeParameterNames {
    if (_typeParameterNames is EqualUnmodifiableListView)
      return _typeParameterNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_typeParameterNames);
  }

  /// type of the executable
  @override
  final ExecutableType type;

  /// whether the executable is a static method
  @override
  final bool isStatic;

  /// entry points for this executable
  final Set<String>? _entryPoints;

  /// entry points for this executable
  @override
  Set<String>? get entryPoints {
    final value = _entryPoints;
    if (value == null) return null;
    if (_entryPoints is EqualUnmodifiableSetView) return _entryPoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(value);
  }

  /// the relative path of the library
  @override
  final String relativePath;

  @override
  String toString() {
    return 'ExecutableDeclaration(returnTypeName: $returnTypeName, returnTypeFullLibraryName: $returnTypeFullLibraryName, name: $name, isDeprecated: $isDeprecated, isExperimental: $isExperimental, parameters: $parameters, typeParameterNames: $typeParameterNames, type: $type, isStatic: $isStatic, entryPoints: $entryPoints, relativePath: $relativePath)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExecutableDeclarationImpl &&
            (identical(other.returnTypeName, returnTypeName) ||
                other.returnTypeName == returnTypeName) &&
            (identical(other.returnTypeFullLibraryName,
                    returnTypeFullLibraryName) ||
                other.returnTypeFullLibraryName == returnTypeFullLibraryName) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.isDeprecated, isDeprecated) ||
                other.isDeprecated == isDeprecated) &&
            (identical(other.isExperimental, isExperimental) ||
                other.isExperimental == isExperimental) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality()
                .equals(other._typeParameterNames, _typeParameterNames) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.isStatic, isStatic) ||
                other.isStatic == isStatic) &&
            const DeepCollectionEquality()
                .equals(other._entryPoints, _entryPoints) &&
            (identical(other.relativePath, relativePath) ||
                other.relativePath == relativePath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      returnTypeName,
      returnTypeFullLibraryName,
      name,
      isDeprecated,
      isExperimental,
      const DeepCollectionEquality().hash(_parameters),
      const DeepCollectionEquality().hash(_typeParameterNames),
      type,
      isStatic,
      const DeepCollectionEquality().hash(_entryPoints),
      relativePath);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExecutableDeclarationImplCopyWith<_$ExecutableDeclarationImpl>
      get copyWith => __$$ExecutableDeclarationImplCopyWithImpl<
          _$ExecutableDeclarationImpl>(this, _$identity);
}

abstract class _ExecutableDeclaration extends ExecutableDeclaration {
  const factory _ExecutableDeclaration(
      {required final String returnTypeName,
      required final String? returnTypeFullLibraryName,
      required final String name,
      required final bool isDeprecated,
      required final bool isExperimental,
      required final List<ExecutableParameterDeclaration> parameters,
      required final List<String> typeParameterNames,
      required final ExecutableType type,
      required final bool isStatic,
      final Set<String>? entryPoints,
      required final String relativePath}) = _$ExecutableDeclarationImpl;
  const _ExecutableDeclaration._() : super._();

  @override

  /// name of the return type
  String get returnTypeName;
  @override // fill library name of the return type
  String? get returnTypeFullLibraryName;
  @override

  /// name of the executable
  String get name;
  @override

  /// whether the executable is deprecated
  bool get isDeprecated;
  @override

  /// whether the executable is experimental
  bool get isExperimental;
  @override

  /// list of the executables parameters ([ExecutableOParameterDeclaration]s)
  List<ExecutableParameterDeclaration> get parameters;
  @override

  /// type parameter names of this executable
  List<String> get typeParameterNames;
  @override

  /// type of the executable
  ExecutableType get type;
  @override

  /// whether the executable is a static method
  bool get isStatic;
  @override

  /// entry points for this executable
  Set<String>? get entryPoints;
  @override

  /// the relative path of the library
  String get relativePath;
  @override
  @JsonKey(ignore: true)
  _$$ExecutableDeclarationImplCopyWith<_$ExecutableDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}
